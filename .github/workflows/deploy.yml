name: deploy
on:
  push:
    branches: [ main ]
  workflow_dispatch: {}
jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    env:
      AZURE_WEBAPP_NAME: oaktree-variance-dev
      AZURE_RESOURCE_GROUP: oaktree-variance-dev-rg
      ACR_NAME: ${{ secrets.ACR_NAME }}       # <-- add this secret in GitHub
    concurrency:
      group: deploy-${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Azure OIDC login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Azure inputs
        shell: bash
        run: |
          set -euo pipefail
          az account show -o table
          az group show -n "$AZURE_RESOURCE_GROUP" -o table
          az webapp show -g "$AZURE_RESOURCE_GROUP" -n "$AZURE_WEBAPP_NAME" -o table

      - name: Check ACR_NAME secret present
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ACR_NAME:-}" ]; then
            echo "::error::ACR_NAME is not set. Add repository secret ACR_NAME (e.g., oaktreevarianceacr)."; exit 1
          fi

      - name: Read ACR info (must already exist)
        shell: bash
        run: |
          set -euo pipefail
          az acr show -n "$ACR_NAME" -o table
          echo "LOGIN_SERVER=$(az acr show -n \"$ACR_NAME\" --query loginServer -o tsv)" >> $GITHUB_ENV

      # Build & push image
      - name: Docker login to ACR
        shell: bash
        run: |
          set -euo pipefail

          # Ensure we have the login server (from prior step or fetch now)
          if [ -z "${LOGIN_SERVER:-}" ]; then
            LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv || true)
          fi
          if [ -z "${LOGIN_SERVER:-}" ]; then
            echo "::error::LOGIN_SERVER is empty; cannot log in to ACR. Verify ACR_NAME secret and ACR exists."
            exit 1
          fi
          echo "ACR login server: $LOGIN_SERVER"

          echo "Trying 'az acr login' (token-based)…"
          if az acr login -n "$ACR_NAME" >/dev/null 2>&1; then
            echo "Logged in to $LOGIN_SERVER via 'az acr login'."
          else
            echo "::warning::'az acr login' failed (likely missing AcrPush). Falling back to admin credentials…"
            # Enable admin (idempotent) and log in with admin username/password
            az acr update -n "$ACR_NAME" --admin-enabled true
            USERNAME=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
            PASSWORD=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)
            if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
              echo "::error::Could not retrieve ACR admin credentials. Ensure admin is enabled on the registry."
              exit 1
            fi
            echo "$PASSWORD" | docker login "$LOGIN_SERVER" --username "$USERNAME" --password-stdin
            echo "Logged in to $LOGIN_SERVER using admin credentials."
          fi

      - name: Build & push image
        shell: bash
        run: |
          set -euo pipefail
          # Re-resolve the ACR login server in this step (env from previous step may not be loaded here)
          LOGIN_SERVER="${LOGIN_SERVER:-$(az acr show -n "$ACR_NAME" --query loginServer -o tsv || true)}"
          if [ -z "${LOGIN_SERVER:-}" ]; then
            echo "::error::LOGIN_SERVER is empty; cannot build a valid image tag. Check ACR_NAME and ACR existence."
            exit 1
          fi
          echo "Using ACR login server: $LOGIN_SERVER"

          IMAGE_REPO="${LOGIN_SERVER}/oaktree-variance"
          TAG="${GITHUB_SHA::7}"

          echo "Building image ${IMAGE_REPO}:${TAG} …"
          docker build -t "${IMAGE_REPO}:${TAG}" -t "${IMAGE_REPO}:latest" .

          echo "Pushing image tags …"
          docker push "${IMAGE_REPO}:${TAG}"
          docker push "${IMAGE_REPO}:latest"

          # Export for later step
          echo "IMAGE_URI=${IMAGE_REPO}:${TAG}" >> "$GITHUB_ENV"

      # Point the Web App to the new image
      - name: Configure Web App to use container image
        shell: bash
        run: |
          set -euo pipefail
          USERNAME=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
          PASSWORD=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)
          # Set container image and registry credentials
          az webapp config container set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --docker-custom-image-name "$IMAGE_URI" \
            --docker-registry-server-url "https://$LOGIN_SERVER" \
            --docker-registry-server-user "$USERNAME" \
            --docker-registry-server-password "$PASSWORD"
          # App settings: tell container which port & module to use (change APP_MODULE if not app:app)
          az webapp config appsettings set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --settings WEBSITES_PORT=8000 APP_MODULE=app:app WEBSITES_CONTAINER_START_TIME_LIMIT=1800 \
                       SCM_DO_BUILD_DURING_DEPLOYMENT=false WEBSITE_RUN_FROM_PACKAGE=0 \
                       DOCKER_ENABLE_CI=true

      - name: Warm up & basic health check
        shell: bash
        env:
          APP_URL: https://oaktree-variance-dev.azurewebsites.net/
        run: |
          set -euo pipefail
          for i in {1..36}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL" || true)
            if [ "$code" = "200" ] || [ "$code" = "302" ]; then
              echo "Site is up with HTTP $code"; exit 0
            fi
            echo "Waiting for container... ($i/36) HTTP $code"
            sleep 10
          done
          echo "::error::Site did not return 200/302 in time."; exit 1
