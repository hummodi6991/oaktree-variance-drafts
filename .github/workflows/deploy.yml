name: deploy
on:
  push:
    branches: [ main ]
  workflow_dispatch: {}
jobs:
  deploy:
    runs-on: ubuntu-latest
    permissions: { id-token: write, contents: read }
    env:
      AZURE_WEBAPP_NAME: oaktree-variance-dev
      AZURE_RESOURCE_GROUP: oaktree-variance-dev-rg
      ACR_NAME: ${{ secrets.ACR_NAME }}       # <-- add this secret in GitHub
    concurrency:
      group: deploy-${{ github.workflow }}-${{ github.ref }}
      cancel-in-progress: true
    steps:
      - uses: actions/checkout@v4

      - name: Detect APP_MODULE automatically
        id: detect_app
        shell: bash
        run: |
          set -euo pipefail
          DETECT=""
          if [ -f main.py ] && grep -qi "FastAPI(" main.py; then
            DETECT="main:app"
          elif [ -f app/main.py ] && grep -qi "FastAPI(" app/main.py; then
            DETECT="app.main:app"
          elif [ -f app.py ] && grep -qi "Flask(" app.py; then
            DETECT="app:app"
          elif ls -1 **/wsgi.py >/dev/null 2>&1; then
            WSGI_PATH=$(ls -1 **/wsgi.py | head -n1)
            # convert path like projectname/wsgi.py -> projectname.wsgi
            DETECT="${WSGI_PATH%/wsgi.py}.wsgi"
            DETECT="${DETECT//\//.}"
          fi

          if [ -z "$DETECT" ]; then
            echo "::warning::Could not detect APP_MODULE. Defaulting to main:app. Adjust if needed."
            DETECT="main:app"
          fi
          echo "APP_MODULE_DETECTED=$DETECT" | tee -a "$GITHUB_ENV"
          echo "detected=$DETECT" >> "$GITHUB_OUTPUT"

      - name: Azure OIDC login
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}

      - name: Validate Azure inputs
        shell: bash
        run: |
          set -euo pipefail
          az account show -o table
          az group show -n "$AZURE_RESOURCE_GROUP" -o table
          az webapp show -g "$AZURE_RESOURCE_GROUP" -n "$AZURE_WEBAPP_NAME" -o table

      - name: Check ACR_NAME secret present
        shell: bash
        run: |
          set -euo pipefail
          if [ -z "${ACR_NAME:-}" ]; then
            echo "::error::ACR_NAME is not set. Add repository secret ACR_NAME (e.g., oaktreevarianceacr)."; exit 1
          fi

      - name: Read ACR info (must already exist)
        shell: bash
        run: |
          set -euo pipefail
          az acr show -n "$ACR_NAME" -o table
          echo "LOGIN_SERVER=$(az acr show -n \"$ACR_NAME\" --query loginServer -o tsv)" >> $GITHUB_ENV

      # Build & push image
      - name: Docker login to ACR
        shell: bash
        run: |
          set -euo pipefail

          # Ensure we have the login server (from prior step or fetch now)
          if [ -z "${LOGIN_SERVER:-}" ]; then
            LOGIN_SERVER=$(az acr show -n "$ACR_NAME" --query loginServer -o tsv || true)
          fi
          if [ -z "${LOGIN_SERVER:-}" ]; then
            echo "::error::LOGIN_SERVER is empty; cannot log in to ACR. Verify ACR_NAME secret and ACR exists."
            exit 1
          fi
          echo "ACR login server: $LOGIN_SERVER"

          echo "Trying 'az acr login' (token-based)…"
          if az acr login -n "$ACR_NAME" >/dev/null 2>&1; then
            echo "Logged in to $LOGIN_SERVER via 'az acr login'."
          else
            echo "::warning::'az acr login' failed (likely missing AcrPush). Falling back to admin credentials…"
            # Enable admin (idempotent) and log in with admin username/password
            az acr update -n "$ACR_NAME" --admin-enabled true
            USERNAME=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
            PASSWORD=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)
            if [ -z "$USERNAME" ] || [ -z "$PASSWORD" ]; then
              echo "::error::Could not retrieve ACR admin credentials. Ensure admin is enabled on the registry."
              exit 1
            fi
            echo "$PASSWORD" | docker login "$LOGIN_SERVER" --username "$USERNAME" --password-stdin
            echo "Logged in to $LOGIN_SERVER using admin credentials."
          fi

      - name: Build image (local only)
        shell: bash
        run: |
          set -euo pipefail
          LOGIN_SERVER="${LOGIN_SERVER:-$(az acr show -n "$ACR_NAME" --query loginServer -o tsv || true)}"
          if [ -z "${LOGIN_SERVER:-}" ]; then
            echo "::error::LOGIN_SERVER is empty; verify ACR_NAME and that the ACR exists."; exit 1
          fi
          IMAGE_REPO="${LOGIN_SERVER}/oaktree-variance"
          TAG="${GITHUB_SHA::7}"
          echo "IMAGE_REPO=$IMAGE_REPO" >> "$GITHUB_ENV"
          echo "IMAGE_TAG=$TAG" >> "$GITHUB_ENV"
          docker build \
            --build-arg BUILDKIT_INLINE_CACHE=1 \
            -t "${IMAGE_REPO}:${TAG}" .

      - name: Smoke test container locally
        shell: bash
        env:
          PORT: "8000"
        run: |
          set -euo pipefail
          IMAGE_REPO="${IMAGE_REPO:?missing}"; TAG="${IMAGE_TAG:?missing}"
          CANDIDATES=()
          # include detected value (if any) and common fallbacks
          if [ -n "${APP_MODULE_DETECTED:-}" ]; then CANDIDATES+=("${APP_MODULE_DETECTED}"); fi
          CANDIDATES+=("main:app" "app.main:app" "app:app")

          run_and_probe () {
            local module="$1"
            local name="smoke_$RANDOM"
            echo "==> Trying APP_MODULE=${module}"
            # run without --rm so we can inspect even if it exits immediately
            docker run -d --name "${name}" -e PORT="${PORT}" -e APP_MODULE="${module}" -p ${PORT}:${PORT} "${IMAGE_REPO}:${TAG}" >/dev/null
            # wait up to ~60s for a response
            for i in {1..60}; do
              code=$(curl -s -o /dev/null -w "%{http_code}" "http://127.0.0.1:${PORT}/" || true)
              if [ "$code" = "200" ] || [ "$code" = "302" ]; then
                echo "Local smoke test PASSED with HTTP $code using APP_MODULE=${module}"
                docker rm -f "${name}" >/dev/null 2>&1 || true
                echo "APP_MODULE_FINAL=${module}" >> "$GITHUB_ENV"
                return 0
              fi
              # if the container already exited, no need to keep waiting
              status=$(docker inspect -f '{{.State.Running}}' "${name}" 2>/dev/null || echo "false")
              if [ "$status" = "false" ]; then
                echo "Container exited early while probing. Logs:"
                docker logs "${name}" || true
                exit_code=$(docker inspect -f '{{.State.ExitCode}}' "${name}" 2>/dev/null || echo "unknown")
                echo "Container exit code: ${exit_code}"
                docker rm -f "${name}" >/dev/null 2>&1 || true
                return 1
              fi
              sleep 1
            done
            echo "Timeout waiting for HTTP response. Logs:"
            docker logs "${name}" || true
            docker rm -f "${name}" >/dev/null 2>&1 || true
            return 1
          }

          # try candidates in order
          for m in "${CANDIDATES[@]}"; do
            if run_and_probe "$m"; then
              exit 0
            fi
            echo "---- Next candidate ----"
          done

          echo "::error::All APP_MODULE candidates failed to serve traffic locally. Check logs above and adjust APP_MODULE or server startup."
          exit 1

      - name: Push image to ACR
        shell: bash
        run: |
          set -euo pipefail
          IMAGE_REPO="${IMAGE_REPO:?}"; TAG="${IMAGE_TAG:?}"
          docker push "${IMAGE_REPO}:${TAG}"
          docker tag "${IMAGE_REPO}:${TAG}" "${IMAGE_REPO}:latest"
          docker push "${IMAGE_REPO}:latest"
          echo "IMAGE_URI=${IMAGE_REPO}:${TAG}" >> "$GITHUB_ENV"

      # Point the Web App to the new image
      - name: Configure Web App to use container image
        shell: bash
        run: |
          set -euo pipefail
          USERNAME=$(az acr credential show -n "$ACR_NAME" --query username -o tsv)
          PASSWORD=$(az acr credential show -n "$ACR_NAME" --query passwords[0].value -o tsv)
          # Set container image and registry credentials
          az webapp config container set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --docker-custom-image-name "$IMAGE_URI" \
            --docker-registry-server-url "https://$LOGIN_SERVER" \
            --docker-registry-server-user "$USERNAME" \
            --docker-registry-server-password "$PASSWORD"

      - name: Ensure app settings (port & entrypoint)
        shell: bash
        run: |
          set -euo pipefail
          APP_MODULE="${APP_MODULE_DETECTED:?}"
          az webapp config appsettings set \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --settings WEBSITES_PORT=8000 APP_MODULE="$APP_MODULE" WEBSITES_CONTAINER_START_TIME_LIMIT=1800
          echo "Configured APP_MODULE=$APP_MODULE and WEBSITES_PORT=8000"

      - name: Enable & tail container logs (background)
        shell: bash
        run: |
          set -euo pipefail
          az webapp log config \
            --name "$AZURE_WEBAPP_NAME" \
            --resource-group "$AZURE_RESOURCE_GROUP" \
            --docker-container-logging filesystem
          ( az webapp log tail --resource-group "$AZURE_RESOURCE_GROUP" --name "$AZURE_WEBAPP_NAME" --timeout 600 || true ) &

      - name: Warm up & basic health check
        shell: bash
        env:
          APP_URL: https://oaktree-variance-dev.azurewebsites.net/
        run: |
          set -euo pipefail
          for i in {1..36}; do
            code=$(curl -s -o /dev/null -w "%{http_code}" "$APP_URL" || true)
            if [ "$code" = "200" ] || [ "$code" = "302" ]; then
              echo "Site is up with HTTP $code"; exit 0
            fi
            echo "Waiting for container... ($i/36) HTTP $code"
            sleep 10
          done
          echo "::error::Site did not return 200/302 in time."; exit 1
